{"cells":[{"cell_type":"code","source":"import rospy\nimport json\nimport yaml # NEW: For parsing YAML configuration files\nimport os   # For path manipulation\n\ndef parse_ros_message_data(msg, fields_map, node_name=\"unknown_node\"):\n    \"\"\"\n    Parses a ROS message into a dictionary, applying default values and validating types.\n    This function handles both native ROS message objects and std_msgs/String messages\n    that contain JSON payloads.\n\n    Args:\n        msg: The incoming ROS message object.\n        fields_map (dict): A dictionary defining expected fields, their default values,\n                           and expected types.\n                           Format: {'desired_key': (default_value, 'msg_field_name', expected_type_or_tuple_of_types)}\n                           'msg_field_name' is the actual field name in the ROS message/JSON.\n                           If msg_field_name is missing, desired_key will be used as field name.\n        node_name (str): The name of the node calling this utility, for logging purposes.\n\n    Returns:\n        dict: A dictionary containing the parsed data. Includes 'parse_success': False\n              and 'error_reason' if validation fails.\n    \"\"\"\n    parsed_data = {'parse_success': True, 'error_reason': None}\n    raw_data_source = {}\n\n    if isinstance(msg, String):\n        try:\n            raw_data_source = json.loads(msg.data)\n        except json.JSONDecodeError as e:\n            rospy.logwarn(f\"{node_name}: JSON decode error in String message: {e}. Raw: '{msg.data[:100]}...'\")\n            parsed_data['parse_success'] = False\n            parsed_data['error_reason'] = f\"JSON decode error: {e}\"\n            # Populate with defaults for all fields to avoid KeyError downstream\n            for key, (default_value, _, _) in fields_map.items():\n                parsed_data[key] = default_value\n            return parsed_data\n    elif hasattr(msg, '__dict__'): # For native ROS messages\n        raw_data_source = msg.__dict__\n    else:\n        rospy.logwarn(f\"{node_name}: Unsupported message type: {type(msg)}. Expected String or native ROS message.\")\n        parsed_data['parse_success'] = False\n        parsed_data['error_reason'] = f\"Unsupported message type: {type(msg)}\"\n        # Populate with defaults for all fields\n        for key, (default_value, _, _) in fields_map.items():\n            parsed_data[key] = default_value\n        return parsed_data\n\n\n    for desired_key, (default_value, msg_field_name, expected_type) in fields_map.items():\n        actual_field_name = msg_field_name if msg_field_name else desired_key # Use msg_field_name if provided\n\n        if actual_field_name in raw_data_source:\n            value = raw_data_source[actual_field_name]\n            # Validate type\n            if not isinstance(value, expected_type):\n                rospy.logwarn(f\"{node_name}: Type mismatch for '{desired_key}' (field '{actual_field_name}'). Expected {expected_type}, got {type(value)}. Using default.\")\n                parsed_data[desired_key] = default_value\n                parsed_data['parse_success'] = False\n                parsed_data['error_reason'] = f\"Type mismatch for '{desired_key}' (expected {expected_type}, got {type(value)})\"\n            else:\n                parsed_data[desired_key] = value\n        else:\n            rospy.logwarn(f\"{node_name}: Field '{desired_key}' (or '{actual_field_name}') not found in message. Using default: {default_value}\")\n            parsed_data[desired_key] = default_value\n            parsed_data['parse_success'] = False\n            parsed_data['error_reason'] = f\"Missing field '{desired_key}'\"\n\n    return parsed_data\n\ndef load_config(node_name, config_file_path):\n    \"\"\"\n    Loads configuration parameters from a centralized YAML file for a specific node.\n\n    Args:\n        node_name (str): The name of the current ROS node (e.g., 'attention_node').\n        config_file_path (str): The absolute path to the sentience_config.yaml file.\n\n    Returns:\n        dict: A dictionary of parameters relevant to the given node,\n              merged with global parameters. Returns an empty dict on error.\n    \"\"\"\n    config = {}\n    try:\n        # Expand user home directory if '~' is used\n        expanded_path = os.path.expanduser(config_file_path)\n        with open(expanded_path, 'r') as f:\n            full_config = yaml.safe_load(f)\n\n        if not isinstance(full_config, dict):\n            rospy.logerr(f\"Config file '{expanded_path}' is not a valid YAML dictionary.\")\n            return {}\n\n        # Load global parameters\n        global_params = full_config.get('global', {})\n        \n        # Initialize node_params with global LLM settings\n        node_params = global_params.get('llm_api', {}).copy()\n        \n        # Override with node-specific parameters\n        node_specific_params = full_config.get(node_name, {})\n        \n        # Merge global LLM parameters with node-specific LLM overrides\n        if 'llm_api' in node_specific_params:\n            # Update global LLM params with node-specific ones\n            node_params.update(node_specific_params.pop('llm_api'))\n\n        # Add remaining node-specific parameters\n        node_params.update(node_specific_params)\n\n        # Handle db_root_path globally and apply to node's db_path\n        db_root_path = os.path.expanduser(global_params.get('db_root_path', \"~/.ros/conscious_robot\"))\n        node_params['db_root_path'] = db_root_path # Make available to all nodes\n\n        # Set default log level\n        node_params['default_log_level'] = global_params.get('default_log_level', 'INFO')\n\n        rospy.loginfo(f\"Successfully loaded configuration for '{node_name}' from '{expanded_path}'.\")\n        return node_params\n\n    except FileNotFoundError:\n        rospy.logerr(f\"Configuration file not found at '{config_file_path}'. Please ensure it exists.\")\n    except yaml.YAMLError as e:\n        rospy.logerr(f\"Error parsing YAML configuration from '{config_file_path}': {e}\")\n    except Exception as e:\n        rospy.logerr(f\"An unexpected error occurred while loading config for '{node_name}': {e}\")\n    return {}","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}