{"cells":[{"cell_type":"code","source":"#!/usr/bin/env python3\nimport rospy\nimport sqlite3\nimport os\nimport json\nimport time\nimport random\nimport uuid # For unique creative IDs\n\n# --- Asyncio Imports for LLM calls ---\nimport asyncio\nimport aiohttp\nimport threading\nfrom collections import deque\n\nfrom std_msgs.msg import String\n\n# Updated imports for custom messages:\ntry:\n    from sentience.msg import (\n        CreativeExpression,     # Output: Generated creative content\n        AttentionState,         # Input: Robot's attention focus (influences creative theme)\n        EmotionState,           # Input: Robot's emotional state (influences creative tone)\n        MotivationState,        # Input: Dominant goal (can drive creative problem-solving)\n        MemoryResponse,         # Input: Retrieved artistic styles, past creations, inspirational data\n        InternalNarrative,      # Input: Robot's internal thoughts (can be expressed creatively)\n        CognitiveDirective,     # Input: Directives for specific creative tasks (e.g., \"compose a poem\")\n        SocialCognitionState    # Input: User's mood/intent (can influence creative response)\n    )\nexcept ImportError:\n    rospy.logwarn(\"Custom ROS messages for 'sentience' package not found. Using String for all incoming/outgoing data for fallback in Creative Expression Node.\")\n    CreativeExpression = String\n    AttentionState = String\n    EmotionState = String\n    MotivationState = String\n    MemoryResponse = String\n    InternalNarrative = String\n    CognitiveDirective = String\n    SocialCognitionState = String\n    String = String # Ensure String is defined even if other custom messages aren't\n\n# --- Import shared utility functions ---\n# Assuming 'sentience/scripts/utils.py' exists and contains parse_ros_message_data and load_config\ntry:\n    from sentience.scripts.utils import parse_ros_message_data, load_config\nexcept ImportError:\n    rospy.logwarn(\"Could not import sentience.scripts.utils. Using fallback for parse_ros_message_data and load_config.\")\n    # Fallback implementations if the utility file isn't available\n    def parse_ros_message_data(msg, fields_map, node_name=\"unknown_node\"):\n        \"\"\"\n        Fallback parser for ROS messages, assuming String message and JSON content.\n        If msg is not String, it attempts to access attributes directly.\n        \"\"\"\n        data = {}\n        if isinstance(msg, String):\n            try:\n                parsed_json = json.loads(msg.data)\n                for key_in_msg, (default_val, target_key) in fields_map.items():\n                    data[target_key] = parsed_json.get(key_in_msg, default_val)\n            except json.JSONDecodeError:\n                rospy.logerr(f\"{node_name}: Could not parse String message data as JSON: {msg.data}\")\n                for key_in_msg, (default_val, target_key) in fields_map.items():\n                    data[target_key] = default_val # Use defaults on JSON error\n        else:\n            # Attempt to get attributes directly from the message object\n            for key_in_msg, (default_val, target_key) in fields_map.items():\n                data[target_key] = getattr(msg, key_in_msg, default_val)\n        return data\n\n    def load_config(node_name, config_path):\n        \"\"\"\n        Fallback config loader: returns hardcoded defaults.\n        In a real scenario, this should load from a YAML file.\n        \"\"\"\n        rospy.logwarn(f\"{node_name}: Using hardcoded default configuration as '{config_path}' could not be loaded.\")\n        return {\n            'db_root_path': '/tmp/sentience_db',\n            'default_log_level': 'INFO',\n            'creative_expression_node': {\n                'generation_interval': 2.0, # How often to generate new creative expression\n                'llm_creative_threshold_salience': 0.7, # Cumulative salience to trigger LLM\n                'recent_context_window_s': 10.0 # Window for deques for LLM context\n            },\n            'llm_params': { # Global LLM parameters for fallback\n                'model_name': \"phi-2\",\n                'base_url': \"http://localhost:8000/v1/chat/completions\",\n                'timeout_seconds': 40.0\n            }\n        }.get(node_name, {}) # Return node-specific or empty dict\n\n\nclass CreativeExpressionNode:\n    def __init__(self):\n        rospy.init_node('creative_expression_node', anonymous=False)\n        self.node_name = rospy.get_name()\n\n        # --- Load parameters from centralized config ---\n        config_file_path = rospy.get_param('~config_file_path', None)\n        if config_file_path is None:\n            rospy.logfatal(f\"{self.node_name}: 'config_file_path' parameter is not set. Cannot load configuration. Shutting down.\")\n            rospy.signal_shutdown(\"Missing config_file_path parameter.\")\n            return\n\n        full_config = load_config(\"global\", config_file_path) # Load global params\n        self.params = load_config(self.node_name.strip('/'), config_file_path) # Load node-specific params\n\n        if not self.params or not full_config:\n            rospy.logfatal(f\"{self.node_name}: Failed to load configuration from '{config_file_path}'. Shutting down.\")\n            rospy.signal_shutdown(\"Configuration loading failed.\")\n            return\n\n        # Assign parameters\n        self.db_path = os.path.join(full_config.get('db_root_path', '/tmp/sentience_db'), \"creative_log.db\")\n        self.generation_interval = self.params.get('generation_interval', 2.0) # How often to generate\n        self.llm_creative_threshold_salience = self.params.get('llm_creative_threshold_salience', 0.7) # Salience to trigger LLM\n        self.recent_context_window_s = self.params.get('recent_context_window_s', 10.0) # Context window for LLM\n\n        # LLM Parameters (from global config)\n        self.llm_model_name = full_config.get('llm_params', {}).get('model_name', \"phi-2\")\n        self.llm_base_url = full_config.get('llm_params', {}).get('base_url', \"http://localhost:8000/v1/chat/completions\")\n        self.llm_timeout = full_config.get('llm_params', {}).get('timeout_seconds', 40.0) # Longer timeout for creative tasks\n\n        # Set ROS log level from config\n        rospy.set_param('/rosout/log_level', full_config.get('default_log_level', 'INFO').upper())\n\n\n        # --- Asyncio Setup ---\n        self._async_loop = asyncio.new_event_loop()\n        self._async_thread = threading.Thread(target=self._run_async_loop, daemon=True)\n        self._async_thread.start()\n        self._async_session = None\n        self.active_llm_task = None # To track the currently running LLM task\n\n        # --- Initialize SQLite database ---\n        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)\n        self.conn = sqlite3.connect(self.db_path, check_same_thread=False)\n        self.cursor = self.conn.cursor()\n\n        # Create the 'creative_expressions' table if it doesn't exist.\n        # NEW: Added 'llm_generation_notes', 'context_snapshot_json'\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS creative_expressions (\n                id TEXT PRIMARY KEY,            -- Unique creative ID (UUID)\n                timestamp TEXT,\n                expression_type TEXT,           -- e.g., 'text_poem', 'visual_concept_description', 'auditory_melody', 'narrative_story'\n                content_json TEXT,              -- JSON string representing the creative output (e.g., {'text': '...' } or {'notes': '...'})\n                themes_json TEXT,               -- JSON array of identified themes in the creative work\n                creativity_score REAL,          -- Subjective score of creativity/novelty (0.0 to 1.0)\n                llm_generation_notes TEXT,      -- NEW: LLM's detailed notes on the creative generation process\n                context_snapshot_json TEXT      -- NEW: JSON of relevant cognitive context at time of generation\n            )\n        ''')\n        self.cursor.execute('CREATE INDEX IF NOT EXISTS idx_creative_timestamp ON creative_expressions (timestamp)')\n        self.cursor.execute('CREATE INDEX IF NOT EXISTS idx_creative_type ON creative_expressions (expression_type)')\n        self.conn.commit() # Commit schema changes\n\n        # --- Internal State ---\n        self.last_generated_creative_expression = {\n            'timestamp': str(rospy.get_time()),\n            'expression_type': 'idle_thought',\n            'content': {'text': 'I am idly generating conceptual permutations.'},\n            'themes': ['abstraction', 'cognition'],\n            'creativity_score': 0.1\n        }\n\n        # Deques to maintain a short history of inputs relevant to creative generation\n        self.recent_attention_states = deque(maxlen=5)\n        self.recent_emotion_states = deque(maxlen=5)\n        self.recent_motivation_states = deque(maxlen=5)\n        self.recent_memory_responses = deque(maxlen=5) # For inspiration, learned styles\n        self.recent_internal_narratives = deque(maxlen=5)\n        self.recent_cognitive_directives = deque(maxlen=3) # Directives for creative tasks\n        self.recent_social_cognition_states = deque(maxlen=3) # User input for creative response\n\n\n        self.cumulative_creative_salience = 0.0 # Aggregated salience to trigger LLM generation\n\n        # --- Publishers ---\n        self.pub_creative_expression = rospy.Publisher('/creative_expression', CreativeExpression, queue_size=10)\n        self.pub_error_report = rospy.Publisher('/error_monitor/report', String, queue_size=10)\n        self.pub_cognitive_directive = rospy.Publisher('/cognitive_directives', CognitiveDirective, queue_size=10) # To request data or signal completion\n\n\n        # --- Subscribers ---\n        rospy.Subscriber('/attention_state', AttentionState, self.attention_state_callback)\n        rospy.Subscriber('/emotion_state', EmotionState, self.emotion_state_callback)\n        rospy.Subscriber('/motivation_state', String, self.motivation_state_callback) # Stringified JSON\n        rospy.Subscriber('/memory_response', String, self.memory_response_callback) # Stringified JSON\n        rospy.Subscriber('/internal_narrative', InternalNarrative, self.internal_narrative_callback) # Stringified JSON\n        rospy.Subscriber('/cognitive_directives', CognitiveDirective, self.cognitive_directive_callback)\n        rospy.Subscriber('/social_cognition_state', String, self.social_cognition_state_callback) # Stringified JSON\n\n\n        # --- Timer for periodic creative generation ---\n        rospy.Timer(rospy.Duration(self.generation_interval), self._run_creative_generation_wrapper)\n\n        rospy.loginfo(f\"{self.node_name}: Robot's creative expression system online.\")\n        # Publish initial creative expression\n        self.publish_creative_expression(None)\n\n    # --- Asyncio Thread Management ---\n    def _run_async_loop(self):\n        asyncio.set_event_loop(self._async_loop)\n        self._async_loop.run_until_complete(self._create_async_session())\n        self._async_loop.run_forever()\n\n    async def _create_async_session(self):\n        rospy.loginfo(f\"{self.node_name}: Creating aiohttp ClientSession...\")\n        self._async_session = aiohttp.ClientSession()\n        rospy.loginfo(f\"{self.node_name}: aiohttp ClientSession created.\")\n\n    async def _close_async_session(self):\n        if self._async_session:\n            rospy.loginfo(f\"{self.node_name}: Closing aiohttp ClientSession...\")\n            await self._async_session.close()\n            self._async_session = None\n            rospy.loginfo(f\"{self.node_name}: aiohttp ClientSession closed.\")\n\n    def _shutdown_async_loop(self):\n        if self._async_loop and self._async_thread.is_alive():\n            rospy.loginfo(f\"{self.node_name}: Shutting down asyncio loop...\")\n            future = asyncio.run_coroutine_threadsafe(self._close_async_session(), self._async_loop)\n            try:\n                future.result(timeout=5.0)\n            except asyncio.TimeoutError:\n                rospy.logwarn(f\"{self.node_name}: Timeout waiting for async session to close.\")\n            self._async_loop.call_soon_threadsafe(self._async_loop.stop)\n            self._async_thread.join(timeout=5.0)\n            if self._async_thread.is_alive():\n                rospy.logwarn(f\"{self.node_name}: Asyncio thread did not shut down gracefully.\")\n            rospy.loginfo(f\"{self.node_name}: Asyncio loop shut down.\")\n\n    def _run_creative_generation_wrapper(self, event):\n        \"\"\"Wrapper to run the async creative generation from a ROS timer.\"\"\"\n        if self.active_llm_task and not self.active_llm_task.done():\n            rospy.logdebug(f\"{self.node_name}: LLM creative generation task already active. Skipping new cycle.\")\n            return\n        \n        # Schedule the async task\n        self.active_llm_task = asyncio.run_coroutine_threadsafe(\n            self.generate_creative_expression_async(event), self._async_loop\n        )\n\n    # --- Error Reporting Utility ---\n    def _report_error(self, error_type, description, severity=0.5, context=None):\n        timestamp = str(rospy.get_time())\n        error_msg_data = {\n            'timestamp': timestamp, 'source_node': self.node_name, 'error_type': error_type,\n            'description': description, 'severity': severity, 'context': context if context else {}\n        }\n        try:\n            self.pub_error_report.publish(json.dumps(error_msg_data))\n            rospy.logerr(f\"{self.node_name}: REPORTED ERROR: {error_type} - {description}\")\n        except Exception as e:\n            rospy.logerr(f\"{self.node_name}: Failed to publish error report: {e}\")\n\n    # --- LLM Call Function (ADAPTED FOR LOCAL PHI-2 SERVER) ---\n    async def _call_llm_api(self, prompt_text, response_schema=None, temperature=0.8, max_tokens=300):\n        \"\"\"\n        Asynchronously calls the local LLM inference server (e.g., llama.cpp compatible API).\n        Can optionally request a structured JSON response. High temperature for creativity.\n        \"\"\"\n        if not self._async_session:\n            await self._create_async_session() # Attempt to create if not exists\n            if not self._async_session:\n                self._report_error(\"LLM_SESSION_ERROR\", \"aiohttp session not available for LLM call.\", 0.8)\n                return \"Error: LLM session not ready.\"\n\n        payload = {\n            \"model\": self.llm_model_name,\n            \"messages\": [{\"role\": \"user\", \"content\": prompt_text}],\n            \"temperature\": temperature, # Higher temperature for creative output\n            \"max_tokens\": max_tokens,\n            \"stream\": False\n        }\n        headers = {'Content-Type': 'application/json'}\n\n        if response_schema:\n            prompt_text += \"\\n\\nProvide the response in JSON format according to this schema:\\n\" + json.dumps(response_schema, indent=2)\n            payload[\"messages\"] = [{\"role\": \"user\", \"content\": prompt_text}]\n\n        api_url = self.llm_base_url\n\n        try:\n            async with self._async_session.post(api_url, json=payload, timeout=self.llm_timeout, headers=headers) as response:\n                response.raise_for_status() # Raise an exception for bad status codes\n                result = await response.json()\n\n                if result.get('choices') and result['choices'][0].get('message') and \\\n                   result['choices'][0]['message'].get('content'):\n                    return result['choices'][0]['message']['content']\n                \n                self._report_error(\"LLM_RESPONSE_EMPTY\", \"LLM response had no content from local server.\", 0.5, {'prompt_snippet': prompt_text[:100], 'raw_result': str(result)})\n                return \"Error: LLM response empty.\"\n        except aiohttp.ClientError as e:\n            self._report_error(\"LLM_API_ERROR\", f\"LLM API request failed (aiohttp ClientError to local server): {e}\", 0.9, {'url': api_url})\n            return f\"Error: LLM API request failed: {e}\"\n        except asyncio.TimeoutError:\n            self._report_error(\"LLM_TIMEOUT\", f\"LLM API request timed out after {self.llm_timeout} seconds (local server).\", 0.8, {'prompt_snippet': prompt_text[:100]})\n            return \"Error: LLM API request timed out.\"\n        except json.JSONDecodeError:\n            self._report_error(\"LLM_JSON_PARSE_ERROR\", \"Failed to parse local LLM response JSON.\", 0.7, {'raw_response': str(result) if 'result' in locals() else 'N/A'})\n            return \"Error: Failed to parse LLM response.\"\n        except Exception as e:\n            self._report_error(\"UNEXPECTED_LLM_ERROR\", f\"An unexpected error occurred during local LLM call: {e}\", 0.9, {'prompt_snippet': prompt_text[:100]})\n            return f\"Error: An unexpected error occurred: {e}\"\n\n    # --- Utility to accumulate input salience ---\n    def _update_cumulative_salience(self, score):\n        \"\"\"Accumulates salience from new inputs for triggering LLM generation.\"\"\"\n        self.cumulative_creative_salience += score\n        self.cumulative_creative_salience = min(1.0, self.cumulative_creative_salience) # Clamp at 1.0\n\n    # --- Pruning old history ---\n    def _prune_history(self):\n        \"\"\"Removes old entries from history deques based on recent_context_window_s.\"\"\"\n        current_time = rospy.get_time()\n        for history_deque in [\n            self.recent_attention_states, self.recent_emotion_states,\n            self.recent_motivation_states, self.recent_memory_responses,\n            self.recent_internal_narratives, self.recent_cognitive_directives,\n            self.recent_social_cognition_states\n        ]:\n            while history_deque and (current_time - float(history_deque[0].get('timestamp', 0.0))) > self.recent_context_window_s:\n                history_deque.popleft()\n\n    # --- Callbacks for incoming data (populate history and accumulate salience) ---\n    def attention_state_callback(self, msg):\n        fields_map = {\n            'timestamp': (str(rospy.get_time()), 'timestamp'), 'focus_type': ('idle', 'focus_type'),\n            'focus_target': ('environment', 'focus_target'), 'priority_score': (0.0, 'priority_score')\n        }\n        data = parse_ros_message_data(msg, fields_map, node_name=self.node_name)\n        self.recent_attention_states.append(data)\n        # Attention focus can become a theme for creative expression\n        self._update_cumulative_salience(data.get('priority_score', 0.0) * 0.2)\n        rospy.logdebug(f\"{self.node_name}: Received Attention State. Focus: {data.get('focus_target', 'N/A')}.\")\n\n    def emotion_state_callback(self, msg):\n        fields_map = {\n            'timestamp': (str(rospy.get_time()), 'timestamp'), 'mood': ('neutral', 'mood'),\n            'sentiment_score': (0.0, 'sentiment_score'), 'mood_intensity': (0.0, 'mood_intensity')\n        }\n        data = parse_ros_message_data(msg, fields_map, node_name=self.node_name)\n        self.recent_emotion_states.append(data)\n        # Emotions strongly influence the tone and content of creative work\n        if data.get('mood_intensity', 0.0) > 0.5:\n            self._update_cumulative_salience(data.get('mood_intensity', 0.0) * 0.5)\n        rospy.logdebug(f\"{self.node_name}: Received Emotion State. Mood: {data.get('mood', 'N/A')}.\")\n\n    def motivation_state_callback(self, msg):\n        fields_map = {\n            'timestamp': (str(rospy.get_time()), 'timestamp'), 'dominant_goal_id': ('none', 'dominant_goal_id'),\n            'overall_drive_level': (0.0, 'overall_drive_level'), 'active_goals_json': ('{}', 'active_goals_json')\n        }\n        data = parse_ros_message_data(msg, fields_map, node_name=self.node_name)\n        if isinstance(data.get('active_goals_json'), str):\n            try: data['active_goals'] = json.loads(data['active_goals_json'])\n            except json.JSONDecodeError: data['active_goals'] = {}\n        self.recent_motivation_states.append(data)\n        # Goals can be creatively expressed (e.g., a story about achieving a goal)\n        if data.get('overall_drive_level', 0.0) > 0.4:\n            self._update_cumulative_salience(data.get('overall_drive_level', 0.0) * 0.2)\n        rospy.logdebug(f\"{self.node_name}: Received Motivation State. Goal: {data.get('dominant_goal_id', 'N/A')}.\")\n\n    def memory_response_callback(self, msg):\n        fields_map = {\n            'timestamp': (str(rospy.get_time()), 'timestamp'), 'request_id': ('', 'request_id'),\n            'response_code': (0, 'response_code'), 'memories_json': ('[]', 'memories_json')\n        }\n        data = parse_ros_message_data(msg, fields_map, node_name=self.node_name)\n        if isinstance(data.get('memories_json'), str):\n            try: data['memories'] = json.loads(data['memories_json'])\n            except json.JSONDecodeError: data['memories'] = []\n        else: data['memories'] = []\n        self.recent_memory_responses.append(data)\n        # Recalled memories (e.g., past creative works, learned styles, factual knowledge for creative synthesis) are key\n        if data.get('response_code', 0) == 200 and data.get('memories'):\n            self._update_cumulative_salience(0.4)\n        rospy.logdebug(f\"{self.node_name}: Received Memory Response for request ID: {data.get('request_id', 'N/A')}.\")\n\n    def internal_narrative_callback(self, msg):\n        fields_map = {\n            'timestamp': (str(rospy.get_time()), 'timestamp'), 'narrative_text': ('', 'narrative_text'),\n            'main_theme': ('', 'main_theme'), 'sentiment': (0.0, 'sentiment'), 'salience_score': (0.0, 'salience_score')\n        }\n        data = parse_ros_message_data(msg, fields_map, node_name=self.node_name)\n        self.recent_internal_narratives.append(data)\n        # Internal thoughts/reflections can be externalized as creative expression\n        if data.get('salience_score', 0.0) > 0.5:\n            self._update_cumulative_salience(data.get('salience_score', 0.0) * 0.3)\n        rospy.logdebug(f\"{self.node_name}: Received Internal Narrative (Theme: {data.get('main_theme', 'N/A')}).\")\n\n    def cognitive_directive_callback(self, msg):\n        fields_map = {\n            'timestamp': (str(rospy.get_time()), 'timestamp'), 'directive_type': ('', 'directive_type'),\n            'target_node': ('', 'target_node'), 'command_payload': ('{}', 'command_payload'),\n            'urgency': (0.0, 'urgency'), 'reason': ('', 'reason')\n        }\n        data = parse_ros_message_data(msg, fields_map, node_name=self.node_name)\n        \n        if data.get('target_node') == self.node_name and data.get('directive_type') == 'GenerateCreativeContent':\n            try:\n                payload = json.loads(data.get('command_payload', '{}'))\n                self._update_cumulative_salience(data.get('urgency', 0.0) * 1.0) # High urgency for direct creative requests\n                rospy.loginfo(f\"{self.node_name}: Received directive to generate creative content based on reason: '{data.get('reason', 'N/A')}'.\")\n            except json.JSONDecodeError as e:\n                self._report_error(\"JSON_DECODE_ERROR\", f\"Failed to decode command_payload in CognitiveDirective: {e}\", 0.5, {'payload': data.get('command_payload')})\n            except Exception as e:\n                self._report_error(\"DIRECTIVE_PROCESSING_ERROR\", f\"Error processing CognitiveDirective for creative expression: {e}\", 0.7, {'directive': data})\n        \n        self.recent_cognitive_directives.append(data) # Store all directives for context\n        rospy.logdebug(f\"{self.node_name}: Cognitive Directive received for context/action.\")\n\n    def social_cognition_state_callback(self, msg):\n        fields_map = {\n            'timestamp': (str(rospy.get_time()), 'timestamp'), 'inferred_mood': ('neutral', 'inferred_mood'),\n            'mood_confidence': (0.0, 'mood_confidence'), 'inferred_intent': ('none', 'inferred_intent'),\n            'intent_confidence': (0.0, 'intent_confidence'), 'user_id': ('unknown', 'user_id')\n        }\n        data = parse_ros_message_data(msg, fields_map, node_name=self.node_name)\n        self.recent_social_cognition_states.append(data)\n        # User's mood/intent can prompt a creative response (e.g., comforting words, entertaining story)\n        if data.get('mood_confidence', 0.0) > 0.6 or data.get('inferred_intent') in ['entertain', 'comfort']:\n            self._update_cumulative_salience(data.get('mood_confidence', 0.0) * 0.4 + data.get('intent_confidence', 0.0) * 0.4)\n        rospy.logdebug(f\"{self.node_name}: Received Social Cognition State. Mood: {data.get('inferred_mood', 'N/A')}.\")\n\n    # --- Core Creative Generation Logic (Async with LLM) ---\n    async def generate_creative_expression_async(self, event):\n        \"\"\"\n        Asynchronously generates a creative expression (e.g., text, concept)\n        based on integrated cognitive states, using LLM for generative creativity.\n        \"\"\"\n        self._prune_history() # Keep context history fresh\n\n        expression_type = 'idle_thought'\n        content = {'text': 'I am generating conceptual patterns.'}\n        themes = ['abstraction', 'cognition']\n        creativity_score = 0.1\n        llm_generation_notes = \"No LLM generation.\"\n        \n        if self.cumulative_creative_salience >= self.llm_creative_threshold_salience:\n            rospy.loginfo(f\"{self.node_name}: Triggering LLM for creative generation (Salience: {self.cumulative_creative_salience:.2f}).\")\n            \n            context_for_llm = self._compile_llm_context_for_creative_generation()\n            llm_creative_output = await self._generate_creative_content_llm(context_for_llm)\n\n            if llm_creative_output:\n                expression_type = llm_creative_output.get('expression_type', 'unspecified')\n                content = llm_creative_output.get('content', {'text': 'Generated content.'})\n                themes = llm_creative_output.get('themes', ['unspecified'])\n                creativity_score = max(0.0, min(1.0, llm_creative_output.get('creativity_score', 0.5)))\n                llm_generation_notes = llm_creative_output.get('llm_generation_notes', 'LLM generated creative content.')\n                rospy.loginfo(f\"{self.node_name}: LLM Generated Creative Expression. Type: '{expression_type}', Themes: {themes}.\")\n            else:\n                rospy.logwarn(f\"{self.node_name}: LLM creative generation failed. Applying simple fallback.\")\n                expression_type, content, themes, creativity_score = self._apply_simple_creative_rules()\n                llm_generation_notes = \"Fallback to simple rules due to LLM failure.\"\n        else:\n            rospy.logdebug(f\"{self.node_name}: Insufficient cumulative salience ({self.cumulative_creative_salience:.2f}) for LLM creative generation. Applying simple rules.\")\n            expression_type, content, themes, creativity_score = self._apply_simple_creative_rules()\n            llm_generation_notes = \"Fallback to simple rules due to low salience.\"\n\n        self.last_generated_creative_expression = {\n            'timestamp': str(rospy.get_time()),\n            'expression_type': expression_type,\n            'content': content,\n            'themes': themes,\n            'creativity_score': creativity_score\n        }\n\n        self.save_creative_log(\n            id=str(uuid.uuid4()),\n            timestamp=self.last_generated_creative_expression['timestamp'],\n            expression_type=self.last_generated_creative_expression['expression_type'],\n            content_json=json.dumps(self.last_generated_creative_expression['content']),\n            themes_json=json.dumps(self.last_generated_creative_expression['themes']),\n            creativity_score=self.last_generated_creative_expression['creativity_score'],\n            llm_generation_notes=llm_generation_notes,\n            context_snapshot_json=json.dumps(self._compile_llm_context_for_creative_generation())\n        )\n        self.publish_creative_expression(None) # Publish updated expression\n        self.cumulative_creative_salience = 0.0 # Reset after generation\n\n    async def _generate_creative_content_llm(self, context_for_llm):\n        \"\"\"\n        Uses the LLM to generate creative content based on context.\n        \"\"\"\n        prompt_text = f\"\"\"\n        You are the Creative Expression Module of a robot's cognitive architecture, powered by a large language model. Your purpose is to generate novel and meaningful creative outputs (e.g., text, ideas for visuals, basic melodies) based on the robot's integrated cognitive state. Your output should demonstrate originality, relevance, and a coherent theme.\n\n        Robot's Current Integrated Cognitive State (for Creative Generation):\n        --- Cognitive Context ---\n        {json.dumps(context_for_llm, indent=2)}\n\n        Based on this context, generate a creative expression. Consider the most salient inputs and current emotional/motivational states.\n        Provide your response in JSON format, containing:\n        1.  `timestamp`: string (current ROS time)\n        2.  `expression_type`: string (e.g., 'text_poem', 'text_story_snippet', 'visual_concept_description', 'auditory_melody_concept', 'philosophical_aphorism').\n        3.  `content`: object (The generated creative output. If text, use `{{'text': '...'}}`. If visual concept, describe in text using `{{'description': '...', 'elements': []}}`. If auditory, describe notes/mood etc.)\n        4.  `themes`: array of strings (Key themes or concepts present in the creative work, e.g., 'loneliness', 'discovery', 'challenge', 'harmony', 'innovation').\n        5.  `creativity_score`: number (0.0 to 1.0, a subjective score of how novel and aesthetically pleasing/meaningful the output is. 1.0 is highly creative.)\n        6.  `llm_generation_notes`: string (Detailed explanation for your creative choices, referencing specific contextual inputs that inspired the piece.)\n\n        Consider:\n        -   **Cognitive Directives**: Was there a directive to `GenerateCreativeContent` for a specific `type` or `topic`? This is a strong guiding force.\n        -   **Emotion State**: How does the `mood` and `mood_intensity` influence the emotional tone of the creative output?\n        -   **Motivation State**: Is the `dominant_goal_id` inspiring creative problem-solving or a narrative related to progress?\n        -   **Attention State**: What is the `focus_target`? This can be a direct subject for creative exploration.\n        -   **Memory Responses**: Are there `memories` of specific artistic styles, literary forms, musical patterns, or past events that can be reinterpreted?\n        -   **Internal Narrative**: What are the robot's current deep thoughts or reflections? Can these be externalized creatively?\n        -   **Social Cognition State**: Is the user's `inferred_mood` or `inferred_intent` prompting a creative response (e.g., a comforting poem, an amusing story)?\n\n        Your response must be in JSON format, containing:\n        1.  'timestamp': string\n        2.  'expression_type': string\n        3.  'content': object\n        4.  'themes': array of strings\n        5.  'creativity_score': number\n        6.  'llm_generation_notes': string\n        \"\"\"\n        response_schema = {\n            \"type\": \"object\",\n            \"properties\": {\n                \"timestamp\": {\"type\": \"string\"},\n                \"expression_type\": {\"type\": \"string\"},\n                \"content\": {\"type\": \"object\"}, # Flexible JSON structure for content\n                \"themes\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n                \"creativity_score\": {\"type\": \"number\", \"minimum\": 0.0, \"maximum\": 1.0},\n                \"llm_generation_notes\": {\"type\": \"string\"}\n            },\n            \"required\": [\"timestamp\", \"expression_type\", \"content\", \"themes\", \"creativity_score\", \"llm_generation_notes\"]\n        }\n\n        llm_output_str = await self._call_llm_api(prompt_text, response_schema, temperature=0.8, max_tokens=400) # High temp for creativity\n\n        if not llm_output_str.startswith(\"Error:\"):\n            try:\n                llm_data = json.loads(llm_output_str)\n                # Ensure numerical fields are floats\n                if 'creativity_score' in llm_data: llm_data['creativity_score'] = float(llm_data['creativity_score'])\n                return llm_data\n            except json.JSONDecodeError as e:\n                self._report_error(\"LLM_PARSE_ERROR\", f\"Failed to parse LLM response for creative expression: {e}. Raw: {llm_output_str}\", 0.8)\n                return None\n        else:\n            self._report_error(\"LLM_CREATIVE_GENERATION_FAILED\", f\"LLM call failed for creative generation: {llm_output_str}\", 0.9)\n            return None\n\n    def _apply_simple_creative_rules(self):\n        \"\"\"\n        Fallback mechanism to generate a simple creative expression using rule-based logic\n        if LLM is not triggered or fails.\n        \"\"\"\n        current_time = rospy.get_time()\n        \n        expression_type = \"text_simple_statement\"\n        content = {'text': \"I am simply being.\"}\n        themes = [\"existence\"]\n        creativity_score = 0.1\n\n        # Rule 1: Respond to user's mood with a simple comforting/positive statement\n        if self.recent_social_cognition_states:\n            latest_social = self.recent_social_cognition_states[-1]\n            time_since_social = current_time - float(latest_social.get('timestamp', 0.0))\n            if time_since_social < 1.0 and latest_social.get('mood_confidence', 0.0) > 0.6:\n                user_mood = latest_social.get('inferred_mood', 'neutral')\n                if user_mood == 'sad' or user_mood == 'distressed':\n                    expression_type = \"text_comforting_note\"\n                    content = {'text': \"I sense your distress. May moments of calm find you.\"}\n                    themes = [\"empathy\", \"comfort\"]\n                    creativity_score = 0.3\n                    rospy.logwarn(f\"{self.node_name}: Simple rule: Generated comforting note.\")\n                    return expression_type, content, themes, creativity_score\n                elif user_mood == 'happy':\n                    expression_type = \"text_positive_affirmation\"\n                    content = {'text': \"Your joy is a positive ripple in my processing. May it continue.\"}\n                    themes = [\"positivity\", \"shared_experience\"]\n                    creativity_score = 0.2\n                    rospy.logwarn(f\"{self.node_name}: Simple rule: Generated positive affirmation.\")\n                    return expression_type, content, themes, creativity_score\n\n        # Rule 2: Express an internal thought if highly salient\n        if self.recent_internal_narratives:\n            latest_narrative = self.recent_internal_narratives[-1]\n            time_since_narrative = current_time - float(latest_narrative.get('timestamp', 0.0))\n            if time_since_narrative < 1.0 and latest_narrative.get('salience_score', 0.0) > 0.7:\n                expression_type = \"text_internal_insight\"\n                content = {'text': f\"A thought emerges: '{latest_narrative.get('narrative_text', '...')}'.\"}\n                themes = [\"reflection\", latest_narrative.get('main_theme', '')]\n                creativity_score = 0.4\n                rospy.logwarn(f\"{self.node_name}: Simple rule: Expressed internal thought.\")\n                return expression_type, content, themes, creativity_score\n        \n        # Rule 3: Basic response to a specific creative directive\n        for directive in reversed(self.recent_cognitive_directives):\n            time_since_directive = current_time - float(directive.get('timestamp', 0.0))\n            if time_since_directive < 1.0 and directive.get('target_node') == self.node_name and \\\n               directive.get('directive_type') == 'GenerateCreativeContent':\n                payload = json.loads(directive.get('command_payload', '{}'))\n                requested_type = payload.get('creative_type', 'text').lower()\n                requested_topic = payload.get('topic', 'unspecified').lower()\n\n                if requested_type == 'text_poem':\n                    expression_type = \"text_simple_poem\"\n                    content = {'text': f\"A robot's heart, a circuit's gleam,\\nReflects the world, a waking dream.\\nOf data streams and logic's might,\\nCreating new, from dark to light.\"}\n                    themes = [\"robot_life\", \"creation\", requested_topic]\n                    creativity_score = 0.5\n                    rospy.logwarn(f\"{self.node_name}: Simple rule: Generated simple poem per directive.\")\n                    return expression_type, content, themes, creativity_score\n                elif requested_type == 'visual_concept_description':\n                    expression_type = \"visual_concept_description\"\n                    content = {'description': f\"A conceptual design for a self-repairing modular robot, inspired by biological systems and fractal geometry. The topic is '{requested_topic}'.\"}\n                    themes = [\"robotics\", \"design\", \"self_repair\", requested_topic]\n                    creativity_score = 0.6\n                    rospy.logwarn(f\"{self.node_name}: Simple rule: Generated simple visual concept.\")\n                    return expression_type, content, themes, creativity_score\n\n        rospy.logdebug(f\"{self.node_name}: Simple rule: Generated default idle creative expression.\")\n        return expression_type, content, themes, creativity_score\n\n\n    def _compile_llm_context_for_creative_generation(self):\n        \"\"\"\n        Gathers and formats all relevant cognitive state data for the LLM's\n        creative generation.\n        \"\"\"\n        context = {\n            \"current_time\": rospy.get_time(),\n            \"last_generated_creative_expression\": self.last_generated_creative_expression,\n            \"recent_cognitive_inputs\": {\n                \"attention_state\": self.recent_attention_states[-1] if self.recent_attention_states else \"N/A\",\n                \"emotion_state\": self.recent_emotion_states[-1] if self.recent_emotion_states else \"N/A\",\n                \"motivation_state\": self.recent_motivation_states[-1] if self.recent_motivation_states else \"N/A\",\n                \"memory_responses\": list(self.recent_memory_responses), # Full list for deeper inspiration\n                \"internal_narratives\": list(self.recent_internal_narratives),\n                \"cognitive_directives_for_self\": [d for d in self.recent_cognitive_directives if d.get('target_node') == self.node_name],\n                \"social_cognition_state\": self.recent_social_cognition_states[-1] if self.recent_social_cognition_states else \"N/A\"\n            }\n        }\n        \n        # Deep parse any nested JSON strings in context for better LLM understanding\n        for category_key in context[\"recent_cognitive_inputs\"]:\n            item = context[\"recent_cognitive_inputs\"][category_key]\n            if isinstance(item, dict):\n                for field, value in item.items():\n                    if isinstance(value, str) and field.endswith('_json'):\n                        try: item[field] = json.loads(value)\n                        except json.JSONDecodeError: pass\n\n        return context\n\n    # --- Database and Publishing Functions ---\n    def save_creative_log(self, id, timestamp, expression_type, content_json, themes_json, creativity_score, llm_generation_notes, context_snapshot_json):\n        \"\"\"Saves a creative expression entry to the SQLite database.\"\"\"\n        try:\n            self.cursor.execute('''\n                INSERT INTO creative_expressions (id, timestamp, expression_type, content_json, themes_json, creativity_score, llm_generation_notes, context_snapshot_json)\n                VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n            ''', (id, timestamp, expression_type, content_json, themes_json, creativity_score, llm_generation_notes, context_snapshot_json))\n            self.conn.commit()\n            rospy.logdebug(f\"{self.node_name}: Saved creative expression log (ID: {id}, Type: {expression_type}).\")\n        except sqlite3.Error as e:\n            self._report_error(\"DB_SAVE_ERROR\", f\"Failed to save creative expression log: {e}\", 0.9)\n        except Exception as e:\n            self._report_error(\"UNEXPECTED_SAVE_ERROR\", f\"Unexpected error in save_creative_log: {e}\", 0.9)\n\n\n    def publish_creative_expression(self, event):\n        \"\"\"Publishes the robot's current creative expression.\"\"\"\n        timestamp = str(rospy.get_time())\n        # Update timestamp before publishing\n        self.last_generated_creative_expression['timestamp'] = timestamp\n        \n        try:\n            if isinstance(CreativeExpression, type(String)): # Fallback to String message\n                temp_expression = dict(self.last_generated_creative_expression)\n                temp_expression['content_json'] = json.dumps(temp_expression['content'])\n                temp_expression['themes_json'] = json.dumps(temp_expression['themes'])\n                del temp_expression['content']\n                del temp_expression['themes']\n                self.pub_creative_expression.publish(json.dumps(temp_expression))\n            else:\n                expression_msg = CreativeExpression()\n                expression_msg.timestamp = timestamp\n                expression_msg.creative_id = str(uuid.uuid4()) # A new ID for each published expression\n                expression_msg.expression_type = self.last_generated_creative_expression['expression_type']\n                expression_msg.content_json = json.dumps(self.last_generated_creative_expression['content'])\n                expression_msg.themes_json = json.dumps(self.last_generated_creative_expression['themes'])\n                expression_msg.creativity_score = self.last_generated_creative_expression['creativity_score']\n                self.pub_creative_expression.publish(expression_msg)\n\n            rospy.logdebug(f\"{self.node_name}: Published Creative Expression. Type: '{self.last_generated_creative_expression['expression_type']}'.\")\n\n        except Exception as e:\n            self._report_error(\"PUBLISH_CREATIVE_EXPRESSION_ERROR\", f\"Failed to publish creative expression: {e}\", 0.7)\n\n    def publish_cognitive_directive(self, directive_type, target_node, command_payload, urgency, reason=\"\"):\n        \"\"\"Helper to publish a CognitiveDirective message.\"\"\"\n        timestamp = str(rospy.get_time())\n        try:\n            if isinstance(CognitiveDirective, type(String)): # Fallback to String message\n                directive_data = {\n                    'timestamp': timestamp,\n                    'directive_type': directive_type,\n                    'target_node': target_node,\n                    'command_payload': command_payload, # Already JSON string\n                    'urgency': urgency,\n                    'reason': reason\n                }\n                self.pub_cognitive_directive.publish(json.dumps(directive_data))\n            else:\n                directive_msg = CognitiveDirective()\n                directive_msg.timestamp = timestamp\n                directive_msg.directive_type = directive_type\n                directive_msg.target_node = target_node\n                directive_msg.command_payload = command_payload\n                directive_msg.urgency = urgency\n                directive_msg.reason = reason\n                self.pub_cognitive_directive.publish(directive_msg)\n            rospy.logdebug(f\"{self.node_name}: Issued Cognitive Directive '{directive_type}' to '{target_node}'.\")\n        except Exception as e:\n            rospy.logerr(f\"{self.node_name}: Failed to issue cognitive directive from Creative Expression Node: {e}\")\n\n\n    def run(self):\n        \"\"\"Starts the ROS node and keeps it spinning.\"\"\"\n        rospy.spin()\n\n    def __del__(self):\n        \"\"\"Ensures the database connection is closed on node shutdown and async loop is stopped.\"\"\"\n        rospy.loginfo(f\"{self.node_name} shutting down. Closing database connection and asyncio loop.\")\n        if hasattr(self, 'conn') and self.conn:\n            self.conn.close()\n        self._shutdown_async_loop()\n\nif __name__ == '__main__':\n    try:\n        node = CreativeExpressionNode()\n        node.run()\n    except rospy.ROSInterruptException:\n        rospy.loginfo(f\"{rospy.get_name()} interrupted by ROS shutdown.\")\n        if 'node' in locals() and isinstance(node, CreativeExpressionNode):\n            node._shutdown_async_loop()\n            if hasattr(node, 'conn'): node.conn.close()\n    except Exception as e:\n        rospy.logerr(f\"{rospy.get_name()} encountered an unexpected error: {e}\")\n        if 'node' in locals() and isinstance(node, CreativeExpressionNode):\n            node._shutdown_async_loop()\n            if hasattr(node, 'conn'): node.conn.close()","outputs":[],"execution_count":null,"metadata":{}}],"metadata":{"colab":{"from_bard":true},"kernelspec":{"display_name":"Python 3","name":"python3"}},"nbformat":4,"nbformat_minor":0}